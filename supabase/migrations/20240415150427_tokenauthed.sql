create role tokenauthed;
grant tokenauthed to authenticator;
grant anon to tokenauthed;

alter role tokenauthed set statement_timeout = '8s';

create table if not exists api_token
(
  id              uuid primary key         not null                                                  default gen_random_uuid(),
  organisation_id uuid                     not null references organisation on delete cascade default private.organisation_id(),
  created_at      timestamp with time zone not null                                                  default now(),
  name            text                     not null
);

alter table api_token enable row level security;

create policy employee_all on api_token to authenticated using (
    (select private.organisation_id()) = organisation_id
);

-- to actually create the api tokens we need to mint our own jwt tokens.
-- we will use the `pgjwt` extension for this.
-- (to learn more about the extension, visit its [github](https://github.com/michelp/pgjwt)
-- page.)
create extension if not exists "pgjwt" with schema "extensions";

comment on extension "pgjwt" is 'json web token api for postgresql';

-- we'll also use a function to help us with the generation.
-- some notes:
-- * this function can generate valid jwts for any user
-- * the token generated by this function is valid forever
-- * we only store the id of the generated token (out of security concerns).
--   the full token will only be provided once, as the return value of this
--   function.
create or replace function create_api_token (organisation_id uuid, name text)
  returns text
  as $token$
declare
  token_id uuid;
  jwt_secret text := coalesce(
    -- live supabase instances store the jwt_secret in the `app.settings.jwt_secret` variable.
    -- you can run `show app.settings.jwt_secret;` in the supabase sql editor for your project
    -- to prove this for yourself.
    -- https://github.com/supabase/supabase-js/issues/25#issuecomment-683239444
    -- https://postgrest.org/en/stable/configuration.html#list-of-parameters
    nullif(current_setting('app.settings.jwt_secret', true), ''),
    -- the jwt secret for local development with [supabase cli](https://supabase.com/docs/guides/local-development)
    -- has the constant value "super-secret-jwt-token-with-at-least-32-characters-long" as an undocumented "feature".
    -- https://github.com/supabase/supabase-js/issues/25#issuecomment-1019935888
    'super-secret-jwt-token-with-at-least-32-characters-long');
begin
  insert into api_token (organisation_id, name)
  values (organisation_id, name)
  returning id into token_id;
  -- since this is an api token to be given to third parties,
  -- we must be careful with the information we include in the payload.
  -- learn more:
  -- * https://supabase.com/docs/learn/auth-deep-dive/auth-deep-dive-jwts
  -- * https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-token-claims
  -- * https://github.com/supabase/gotrue/blob/master/api/token.go
  -- * https://jwt.io/
  return extensions.sign(json_build_object(
      -- id of the token to support immediate revocation
      'tid', token_id,
      -- issuer
      'iss', 'supabase',
      -- subject, i.e. the user to whom this token is tied.
      -- this field is read by `organisation_id()` and must therefore match the
      -- organisation who owns the token.
      'sub', organisation_id,
      -- this field is read by `auth.role()`. it is also used by postgrest to
      -- determine which role to use when accessing your database.
      -- normally, this would be `authenticated`, but we'll use `tokenauthed`
      -- instead to allow for improved security.
      'role', 'tokenauthed',
      -- issued at
      'iat', trunc((extract(epoch from Now()))::numeric, 0)
    ), jwt_secret::text,
  -- supabase tokens currently use the hs256 algorithm
  -- https://github.com/supabase/gotrue/blob/f9b28dd076450ba1d24db17e6c68f39f502dab4c/api/token.go#l548
  'HS256'::text);
end;
$token$
security invoker
language plpgsql;

-- to help extracting the token id from incoming requests, we'll add the following
-- helper function, based on `auth.uid`.
-- see also
-- https://github.com/supabase/supabase/blob/76e1254a91cd5c6b1eb80d3faf19cfd6a3735a95/docker/volumes/db/init/01-auth-schema.sql
create or replace function private.tid ()
  returns uuid
  language 'sql'
  stable
  as $body$
  select coalesce(nullif (current_setting('request.jwt.claim.tid', true), ''), (nullif (current_setting('request.jwt.claims', true), '')::jsonb ->> 'tid'))::uuid
$body$;

create or replace function private.organisation_id() returns uuid as
$$
  select (
    case
        -- when authenticated, auth.uid() is never null
        when auth.role() = 'authenticated' then (select organisation_id from employee where user_id = auth.uid())
        when auth.role() = 'tokenauthed' then (
            select coalesce(nullif (current_setting('request.jwt.claim.sub', true), ''), (nullif (current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub'))::uuid
        )
        end
);
$$ language sql stable security definer;


drop policy employee_all on contact;

create policy employee_tokenauthed_all on contact to authenticated, tokenauthed using (
    (select private.organisation_id()) = organisation_id
);

