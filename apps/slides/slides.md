---
theme: default
title: How To Build a Public API in 10 Minutes
class: text-center
highlighter: shiki
# enable MDC Syntax: https://sli.dev/guide/syntax#mdc-syntax
mdc: true
---

# Build a Public API in 10 Minutes with Supabase

---

# What we start with

```sql {0-5|7-12|14-20}
create table organisation
(
  id uuid primary key not null default gen_random_uuid(),
  name text unique not null
);

create table employee
(
  id uuid primary key not null default gen_random_uuid(),
  organisation_id uuid not null references organisation on update restrict on delete cascade default private.organisation_id(),
  user_id uuid unique references auth.users on update restrict on delete cascade
);

-- we want to expose this in our public api!
create table contact
(
  id uuid primary key not null default gen_random_uuid(),
  organisation_id uuid not null references organisation on delete cascade default private.organisation_id(),
  full_name text
);
```

---

# Auth Setup

- An employee has access to their organisations resources.

```sql {0-4|6-16}
create or replace function private.organisation_id() returns uuid as
$sql$
select organisation_id from employee where user_id = auth.uid()
$sql$ language sql stable security definer;

create policy employee_all on organisation to authenticated using (
    (select private.organisation_id()) = id
);

create policy employee_all on employee to authenticated using (
    (select private.organisation_id()) = organisation_id
);

create policy employee_all on contact to authenticated using (
    (select private.organisation_id()) = organisation_id
);
```

---

# Now to the fun part!

- Create the Role with same permissions as `authenticator`

```sql
create role tokenauthed;
grant tokenauthed to authenticator;
grant anon to tokenauthed;
```

---

# Store a reference to the token in a table

```sql
create table if not exists api_token
(
  id              uuid primary key         not null                                                  default gen_random_uuid(),
  organisation_id uuid                     not null references organisation on delete cascade default private.organisation_id(),
  created_at      timestamp with time zone not null                                                  default now(),
  name            text                     not null
);

alter table api_token enable row level security;

create policy employee_all on api_token to authenticated using (
    (select private.organisation_id()) = organisation_id
);
```

---

# Allow users to actually create a token

- To actually create the api tokens we need to mint our own jwt tokens. We will use the `pgjwt` extension for this.

<!--
we'll also use a function to help us with the generation.
some notes:
* this function can generate valid jwts for any user
* the token generated by this function is valid forever
* we only store the id of the generated token (out of security concerns).
  the full token will only be provided once, as the return value of this

--

Live supabase instances store the jwt_secret in the `app.settings.jwt_secret` variable.
you can run `show app.settings.jwt_secret;` in the supabase sql editor for your project
to prove this for yourself.

--

the jwt secret for local development with [supabase cli](https://supabase.com/docs/guides/local-development)
has the constant value "super-secret-jwt-token-with-at-least-32-characters-long" as an undocumented "feature".
-->

```sql {all|1|6-9|13-19}
create extension if not exists "pgjwt" with schema "extensions";
create or replace function create_api_token (organisation_id uuid, name text)
returns text as $token$
declare
  token_id uuid;
  jwt_secret text := coalesce(
    nullif(current_setting('app.settings.jwt_secret', true), ''),
    'super-secret-jwt-token-with-at-least-32-characters-long'
  );
begin
  insert into api_token (organisation_id, name) values (organisation_id, name)
  returning id into token_id;
  return extensions.sign(json_build_object(
      'tid', token_id, 'iss', 'supabase', 'sub', organisation_id,
      'role', 'tokenauthed', 'iat', trunc((extract(epoch from Now()))::numeric, 0)
    ),
    jwt_secret::text,
    'HS256'::text
  );
end;
$token$ security invoker language plpgsql;
```

---

# Allow `tokenauthed` to access `contact`

- First we need to function to extract the `tid` from the jwt token, similar to `auth.uid()`

```sql
create or replace function private.tid ()
  returns uuid language 'sql' stable
  as $body$
  select coalesce(
    nullif (current_setting('request.jwt.claim.tid', true), ''),
    (nullif (current_setting('request.jwt.claims', true), '')::jsonb ->> 'tid')
  )::uuid
$body$;
```

---

# Allow `tokenauthed` to access `contact`

- Now update `private.organisation_id()` to use `private.tid()` when the role is `tokenauthed`

```sql
create or replace function private.organisation_id() returns uuid as
$sql$
  select (
    case
        when auth.role() = 'authenticated'
            then (select organisation_id from employee where user_id = auth.uid())
        when auth.role() = 'tokenauthed'
            then (
                select coalesce(
                    nullif (current_setting('request.jwt.claim.sub', true), ''),
                    (nullif (current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
                )::uuid
            )
    end
);
$sql$ language sql stable security definer;
```

---

# Allow `tokenauthed` to access `contact`

- Finally, re-create the policy to include `tokenauthed`

```sql
drop policy employee_all on contact;

create policy employee_tokenauthed_all on contact to authenticated, tokenauthed using (
    (select private.organisation_id()) = organisation_id
);
```

---

# Create the API Schema

- We do not want to expose our `public` schema to the public, so we create a new schema `api`

```sql
create schema api;

grant usage on schema api to postgres, anon, authenticated, service_role, tokenauthed;
alter default privileges in schema api grant all on tables to postgres, anon, authenticated, service_role, tokenauthed;
alter default privileges in schema api grant all on functions to postgres, anon, authenticated, service_role, tokenauthed;
alter default privileges in schema api grant all on sequences to postgres, anon, authenticated, service_role, tokenauthed;
```

---

# Expose the `contact` table

- We use "updateable views" and the `security_invoker` config in postgres to expose the `contact` table to the public.
- For better performance, we automatically filter the rows by the `organisation_id` of the token.
- We can also select a subset of columns to expose.

```sql
create view api.contact with (security_invoker) as
select id, full_name
from contact
where organisation_id = private.organisation_id();
```

---

# The Proxy

- Our database is now ready to be accessed by the public! But how to apply rate-limiting and other security measures?

```shell
bunx create-hono api-proxy
```

---

# Create a simple Hono handler with a single route

- We use the `jwt` secret from supabase auth to verify the token.

```ts
const app = new Hono<Env>();

app.use((c, next) => {
  const jwtMiddleware = jwt({
    secret: c.env.SUPABASE_JWT_SECRET,
    alg: "HS256",
  });
  return jwtMiddleware(c, next);
});
```

---

# The Route

- The handler itself is a simple "catch-all" route that forwards the request to the upstream supabase instance.

```ts
app.all("/:table", async (c) => {
  const searchParams =
    c.req.url.indexOf("?") > -1 ? c.req.url.slice(c.req.url.indexOf("?")) : "";

  const upstreamUrl = `${c.env.SUPABASE_URL}/rest/v1/${c.req.param("table")}${searchParams}`;

  const newRequest = new Request(upstreamUrl, c.req.raw);
  const res = await fetch(newRequest);
  const newResponse = new Response(res.body, res);
  return newResponse;
});
```

---

# Restricting access to certain tables

- We can additionally restrict access to certain tables by adding a validator to the route.

```ts
import { object, picklist } from "valibot";
import { vValidator } from "@hono/valibot-validator";

const TABLES = ["contact"];

const paramsSchema = object({
  table: picklist(TABLES),
});

app.all(
  "/:table",
  vValidator<typeof paramsSchema, "param", Env, any>("param", paramsSchema),
  async (c) => {
    // ...
  },
);
```

---

# Add required headers

- For kong to accept the request, we need to set the `anon` key as the `apiKey` header.
- We also need to set the `Accept-Profile` and `Content-Profile` headers to select the `api` schema.
- We can also change the default behavior of PostgREST, e.g. to return the updated row by default.

```ts {7-20}
app.all(
  "/:table",
  vValidator<typeof paramsSchema, "param", Env, any>("param", paramsSchema),
  async (c) => {
    //  ...
    const newRequest = new Request(upstreamUrl, c.req.raw);
    newRequest.headers.set("apiKey", c.env.SUPABASE_ANON_KEY);
    if (["GET", "HEAD"].includes(c.req.method)) {
      newRequest.headers.set("Accept-Profile", "api");
    } else {
      newRequest.headers.set("Content-Profile", "api");
    }
    // ...
  },
);
```

---

# Custom headers too?

- We can change the default behavior of PostgREST, e.g. to return the updated row by default.

```ts {7-20}
app.all(
  "/:table",
  vValidator<typeof paramsSchema, "param", Env, any>("param", paramsSchema),
  async (c) => {
    //  ...
    const newRequest = new Request(upstreamUrl, c.req.raw);
    // ...
    if (c.req.query("select")) {
      newRequest.headers.set(
        "Prefer",
        [c.req.header("Prefer"), "return=representation"]
          .filter(Boolean)
          .join(","),
      );
    }
    // ...
  },
);
```

---

# Done!

## Next Steps / Improvements

- Add rate limiting
- Set statement timeout for `tokenauthed` role to a smaller value, e.g. `2s`
- expose custom routes for eg rpc calls or storage features
- Add logging and monitoring
- ...

- Full source code to copy on [GitHub](https://github.com/psteinroe/supabase-public-api-demo)
